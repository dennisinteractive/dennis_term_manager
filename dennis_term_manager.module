<?php

/**
 * @file
 * Module file Dennis Term Manager.
 */

define('DENNIS_TERM_MANAGER_ACTION_CREATE', 'create');
define('DENNIS_TERM_MANAGER_ACTION_DELETE', 'delete');
define('DENNIS_TERM_MANAGER_ACTION_MERGE', 'merge');
define('DENNIS_TERM_MANAGER_ACTION_RENAME', 'rename');
define('DENNIS_TERM_MANAGER_ACTION_MOVE_PARENT', 'move parent');
define('DENNIS_TERM_MANAGER_ACTION_COMPLETE', 'complete');
define('DENNIS_TERM_MANAGER_DESTINATION_DOWNLOAD', '1');
define('DENNIS_TERM_MANAGER_DESTINATION_FILE', '2');
define('DENNIS_TERM_MANAGER_PUBLIC_FOLDER', 'public://term_manager');
define('DENNIS_TERM_MANAGER_PRIVATE_FOLDER', 'private://term_manager');

require_once "tests/dennis_term_manager.tests.inc";

/**
 * Implements hook_views_api().
 */
function dennis_term_manager_views_api() {
  return array(
    'api' => 3.0,
    'path' => drupal_get_path('module', 'dennis_term_manager')
  );
}

/**
 * Implements hook_permission().
 */
function dennis_term_manager_permission() {
  return array(
    'administer dennis term manager' => array(
      'title' => t('Administer term manager'),
      'description' => t('Manage Dennis taxonomy terms CSV bulk operation'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function dennis_term_manager_menu() {

  $items = array();
  $weight = 0;
  $items['admin/structure/taxonomy/term_manager'] = array(
    'title' => 'Term Manager',
    'description' => 'Manage bulk taxonomy term operation via CSV file upload',
    'page callback' => 'drupal_get_form',
    'page arguments' => array(
      'dennis_term_manager_form',
    ),
    'access arguments' => array(
      'administer dennis term manager',
    ),
    'type' => MENU_LOCAL_TASK,
    'weight' => $weight++,
  );
  $items['admin/structure/taxonomy/term_manager/manage'] = array(
    'title' => 'Manage',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => $weight++,
  );
  $items['admin/structure/taxonomy/term_manager/export_tsv'] = array(
    'title' => 'TSV Export',
    'description' => 'Download tab separated data',
    'page callback' => 'dennis_term_manager_export_terms',
    'access arguments' => array(
      'administer dennis term manager',
    ),
    'type' => MENU_LOCAL_TASK,
    'weight' => $weight++,
  );
  $items['admin/structure/taxonomy/term_manager/export_csv'] = array(
    'title' => 'CSV Export',
    'description' => 'Download comma separated data',
    'page callback' => 'dennis_term_manager_export_terms',
    'page arguments' => array(','),
    'access arguments' => array(
      'administer dennis term manager',
    ),
    'type' => MENU_LOCAL_TASK,
    'weight' => $weight++,
  );
  $items['admin/structure/taxonomy/term_manager/template_tsv'] = array(
    'title' => 'TSV Template',
    'description' => 'Download tab separated template',
    'page callback' => 'dennis_term_manager_download_template',
    'access arguments' => array(
      'administer dennis term manager',
    ),
    'type' => MENU_LOCAL_TASK,
    'weight' => $weight++,
  );
  $items['admin/structure/taxonomy/term_manager/template_csv'] = array(
    'title' => 'CSV Template',
    'description' => 'Download comma separated template',
    'page callback' => 'dennis_term_manager_download_template',
    'page arguments' => array(','),
    'access arguments' => array(
      'administer dennis term manager',
    ),
    'type' => MENU_LOCAL_TASK,
    'weight' => $weight++,
  );
  $items['admin/structure/taxonomy/term_manager/settings'] = array(
    'title' => 'Settings',
    'description' => 'Configure Dennis Term Manager.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('dennis_term_manager_admin_settings_form'),
    'access arguments' => array('administer dennis term manager'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'dennis_term_manager.admin.inc',
    'weight' => $weight++,
  );
  $items['admin/structure/taxonomy/term_manager/help'] = array(
    'title' => 'Help',
    'description' => 'Dennis Term Manager help.',
    'page callback' => 'drupal_goto',
    'page arguments' => array('admin/help/dennis_term_manager'),
    'access arguments' => array('administer dennis term manager'),
    'type' => MENU_LOCAL_TASK,
    'weight' => $weight++,
  );

  return $items;
}

/**
 * Download CSV/TSV template.
 */
function dennis_term_manager_download_template($delimiter = "\t") {
  // Send correct header to download file.
  $extension = $delimiter == "\t" ? 'tsv' : 'csv';
  drupal_add_http_header('Content-Type', 'text/' . $extension . '; charset=utf-8');
  $file_name = 'taxonomy_template_' . date('Y-m-d_H-i-s', REQUEST_TIME) . '.' . $extension;
  drupal_add_http_header('Content-Disposition', 'attachment; filename=' . $file_name);

  $columns = dennis_term_manager_default_columns();
  $out = fopen('php://output', 'w');
  fputcsv($out, $columns, $delimiter, '"');
}

/**
 * Get existing taxonomy usage.
 *
 * @param $vocabs
 *    Array of vocabulary names, used to limit the results.
 */
function _dennis_term_manager_export_terms_query($vocabs = array()) {
  $query = db_select('taxonomy_term_data', 't');

  // Term vocabulary and name.
  $query->addField('v', 'name', 'vocabulary_name');
  $query->addField('t', 'name', 'term_name');

  // Filter by vocabulary
  $machine_names = array();
  if (!empty($vocabs)) {
    foreach ($vocabs as $name) {
      $machine_names[] = _dennis_term_manager_machine_name($name);
    }
    $query->condition('v.machine_name', $machine_names, 'IN');
  }

  // Join alias.
  $query->leftJoin('url_alias', 'ua', "ua.source = CONCAT('taxonomy/term/', CAST(t.tid AS CHAR))");
  $query->addField('ua', 'alias', 'path');

  // TID and VID
  $query->addField('v', 'vid', 'vid');
  $query->addField('t', 'tid', 'tid');

  // Get node count for term.
  $query->addExpression('(SELECT COUNT(1) FROM taxonomy_index i WHERE i.tid = t.tid)', 'node_count');

  // Get child term count for term.
  $query->addExpression('(SELECT COUNT(1) FROM taxonomy_term_hierarchy h WHERE h.parent = t.tid)', 'term_child_count');

  // Parent term name.
  $query->addExpression('IF(p.name IS NULL, \'\', p.name)', 'parent_term_name');

  // Join on vocabulary of term.
  $query->leftJoin('taxonomy_vocabulary', 'v', 'v.vid = t.vid');

  // Parent information.
  $query->leftJoin('taxonomy_term_hierarchy', 'h', 'h.tid = t.tid');
  $query->leftJoin('taxonomy_term_data', 'p', 'p.tid = h.parent');
  $query->addField('p', 'tid', 'parent_tid');

  // Group by tid to get node counts for each term.
  $query->groupBy('t.tid');

  return $query;
}

/**
 * Export current taxonomy.
 */
function dennis_term_manager_export_terms($delimiter = "\t", $vocabs = array(), $columns = array(), $destination = DENNIS_TERM_MANAGER_DESTINATION_DOWNLOAD) {
  $query = _dennis_term_manager_export_terms_query($vocabs);
  $result = $query->execute();

  // Send correct header to download file.
  $extension = $delimiter == "\t" ? 'tsv' : 'csv';
  $file_name = 'taxonomy_export_' . date('Y-m-d_H-i-s', REQUEST_TIME) . '.' . $extension;

  // Add default CSV/TSV headings.
  if (empty($columns)) {
    $columns = dennis_term_manager_default_columns();
  }

  switch ($destination) {
    case DENNIS_TERM_MANAGER_DESTINATION_DOWNLOAD :
      drupal_add_http_header('Content-Type', 'text/' . $extension . '; utf-8');
      drupal_add_http_header('Content-Disposition', 'attachment; filename=' . $file_name);

      $out = fopen('php://output', 'w');
      break;

    case DENNIS_TERM_MANAGER_DESTINATION_FILE:
      $location = _dennis_term_manager_get_files_folder();

      $out = fopen($location . '/taxonomy_export.csv', 'w');
      break;
  }

  fputcsv($out, $columns, $delimiter, '"');

  while ($row = $result->fetchObject()) {
    // Add report data to corresponding column.
    $row_data = array();
    foreach ($columns as $column) {
      $row_data[] = isset($row->{$column}) ? $row->{$column} : '';
    }
    fputcsv($out, $row_data, $delimiter, '"');
  }
}

/**
 * Implements hook_help().
 */
function dennis_term_manager_help($path, $arg) {
  $output = '';

  // CSS to display lists correctly.
  $css = '
  <style type="text/css">
    .import-notes ul {
       list-style-type: disc;
       list-style-position: inside;
    }
    .import-notes ol {
       list-style-type: decimal;
       list-style-position: inside;
    }
    .import-notes li {
      display: list-item;
      list-style: inherit;
    }
    .import-notes ul ul {
       list-style-type: circle;
       list-style-position: inside;
       margin-left: 15px;
    }
  </style>';

  switch ($path) {
    case 'admin/structure/taxonomy/term_manager':
      $output .= $css;
      $output .= '<div class="import-notes">';
      $output .= '<p><strong>How to use it</strong></p>

                <ol>
                  <li>Click on <em>Manage -&gt;&nbsp;TSV/CSV&nbsp;Template</em> to use as starting point from an empty file. Or click <em>Manage -&gt; TSV/CSV Export</em> to have list of the full taxonomy usage.</li>
                  <li>Edit the downloaded file and create the <strong>actions</strong>. To know what columns to use for each action, see the <a href="/admin/help/dennis_term_manager">help</a> page.</li>
                  <li>Click <strong>Choose file</strong> and Upload</li>
                  <li>Click <strong>Import</strong></li>
                </ol>';
      $output .= '</div>';
      break;

    case 'admin/help#dennis_term_manager':
      $output .= $css;
      $output .= '<div class="import-notes">';
      $output .= '<a name="vocabulary_name"></a><p>&nbsp;</p>';
      $output .= '<p><strong>vocabulary_name</strong></p>';
      $output .= '<ul>';
      $output .= '  <li>Vocabulary of existing/source term</li>';
      $output .= '  <li>Used by all actions</li>';
      $output .= '</ul>';

      $output .= '<a name="term_name"></a><p>&nbsp;</p>';
      $output .= '<p><strong>term_name</strong></p>';
      $output .= '<ul>';
      $output .= '  <li>Name of existing/source term</li>';
      $output .= '  <li>Used by all actions</li>';
      $output .= '</ul>';

      $output .= '<a name="tid"></a><p>&nbsp;</p>';
      $output .= '<p><strong>tid</strong></p>';
      $output .= '<ul>';
      $output .= '  <li>Only required when <a href="#term_name">term_name</a> is duplicated</li>';
      $output .= '  <li>Used by "delete", "merge", "move parent"</li>';
      $output .= '</ul>';

      $output .= '<a name="path"></a><p>&nbsp;</p>';
      $output .= '<p><strong>path</strong></p>';
      $output .= '<ul>';
      $output .= '  <li>Information only. Not used by any action</li>';
      $output .= '</ul>';

      $output .= '<a name="node_count"></a><p>&nbsp;</p>';
      $output .= '<p><strong>node_count</strong></p>';
      $output .= '<ul>';
      $output .= '  <li>Count of existing term nodes</li>';
      $output .= '  <li>Information only. Not used by any action</li>';
      $output .= '</ul>';

      $output .= '<a name="term_child_count"></a><p>&nbsp;</p>';
      $output .= '<p><strong>term_child_count</strong></p>';
      $output .= '<ul>';
      $output .= '  <li>Count of child terms</li>';
      $output .= '  <li>Information only. Not used by any action</li>';
      $output .= '</ul>';

      $output .= '<a name="parent_term_name"></a><p>&nbsp;</p>';
      $output .= '<p><strong>parent_term_name</strong></p>';
      $output .= '<ul>';
      $output .= '  <li>Name of existing term parent</li>';
      $output .= '  <li>Used by "create"</li>';
      $output .= '</ul>';

      $output .= '<a name="action"></a><p>&nbsp;</p>';
      $output .= '<p><strong>action</strong></p>';
      $output .= '<ul>';
      $output .= '  <li>"create"';
      $output .= '  <ul>';
      $output .= '    <li>Requires: <a href="#vocabulary_name">vocabulary_name</a>, <a href="#term_name">term_name</a></li>';
      $output .= '    <li>Optional: <a href="#parent_term_name">parent_term_name</a></li>';
      $output .= '  </ul>';
      $output .= '  </li>';
      $output .= '  <li>"delete"';
      $output .= '  <ul>';
      $output .= '    <li>Requires: <a href="#vocabulary_name">vocabulary_name</a>, <a href="#term_name">term_name</a></li>';
      $output .= '    <li>Optional: <a href="#tid">tid</a></li>';
      $output .= '  </ul>';
      $output .= '  </li>';
      $output .= '  <li>"merge"';
      $output .= '  <ul>';
      $output .= '    <li>Requires: <a href="#vocabulary_name">vocabulary_name</a>, <a href="#term_name">term_name</a>, <a href="#target_vocabulary_name">target_vocabulary_name</a>, <a href="#target_term_name">target_term_name</a></li>';
      $output .= '    <li>Optional: <a href="#tid">tid</a>, <a href="#target_tid">target_tid</a>, <a href="#target_field">target_field</a>, <a href="#redirect">redirect</a></li>';
      $output .= '  </ul>';
      $output .= '  </li>';
      $output .= '  <li>"rename"';
      $output .= '  <ul>';
      $output .= '    <li>Requires: <a href="#vocabulary_name">vocabulary_name</a>, <a href="#term_name">term_name</a>, <a href="#new_name">new_name</a></li>';
      $output .= '  </ul>';
      $output .= '  </li>';
      $output .= '  <li>"move parent"';
      $output .= '  <ul>';
      $output .= '    <li>Requires: <a href="#vocabulary_name">vocabulary_name</a>, <a href="#term_name">term_name</a>, <a href="#target_term_name">target_term_name</a></li>';
      $output .= '    <li>Optional: <a href="#target_tid">target_tid</a></li>';
      $output .= '    <li>Set <a href="#target_term_name">target_term_name</a> to empty "" to make it a root item</li>';
      $output .= '    <li>note: You can only move terms within same vocabulary</li>';
      $output .= '  </ul>';
      $output .= '  </li>';
      $output .= '</ul>';

      $output .= '<a name="target_term_name"></a><p>&nbsp;</p>';
      $output .= '<p><strong>target_term_name</strong></p>';
      $output .= '<ul>';
      $output .= '  <li>Name of target term</li>';
      $output .= '  <li>Used by "merge", "move parent"</li>';
      $output .= '</ul>';

      $output .= '<a name="target_tid"></a><p>&nbsp;</p>';
      $output .= '<p><strong>target_tid</strong></p>';
      $output .= '<ul>';
      $output .= '  <li>Only required when <a href="#target_term_name">target_term_name</a> is duplicated</li>';
      $output .= '  <li>Used by "merge", "move parent"</li>';
      $output .= '</ul>';

      $output .= '<a name="target_vocabulary_name"></a><p>&nbsp;</p>';
      $output .= '<p><strong>target_vocabulary_name</strong></p>';
      $output .= '<ul>';
      $output .= '  <li>Vocabulary of target term</li>';
      $output .= '  <li>Used by "merge"</li>';
      $output .= '</ul>';

      $output .= '<a name="target_field"></a><p>&nbsp;</p>';
      $output .= '<p><strong>target_field</strong></p>';
      $output .= '<ul>';
      $output .= '  <li>Comma separated list of fields to merge into</li>';
      $output .= '  <li>Used by "merge"</li>';
      $output .= '  <li>This is only required when merging across vocabularies</li>';
      $output .= '  <li>Example: "field_category_primary,field_category_secondary" will set the node primary category first if empty, otherwise will append to secondary</li>';
      $output .= '</ul>';

      $output .= '<a name="new_name"></a><p>&nbsp;</p>';
      $output .= '<p><strong>new_name</strong></p>';
      $output .= '<ul>';
      $output .= '  <li>New term name</li>';
      $output .= '  <li>Used by "rename"</li>';
      $output .= '</ul>';

      $output .= '<a name="redirect"></a><p>&nbsp;</p>';
      $output .= '<p><strong>redirect</strong></p>';
      $output .= '<ul>';
      $output .= '  <li>Redirect to target term';
      $output .= '    <ul>';
      $output .= '      <li>"301", "Y" or "": 301 redirect to target term</li>';
      $output .= '      <li>"N": do not redirect to target term</li>';
      $output .= '    </ul>';
      $output .= '  </li>';
      $output .= '  <li>Used by "merge"</li>';
      $output .= '</ul>';
      $output .= '</div>';
  }

  return $output;
}

/**
 * Dennis Term Manager Form.
 */
function dennis_term_manager_form($form, &$form_state) {
  // Set the current page title.
  drupal_set_title(t('Term Manager'));

  $form = array();

  // Display current process.
  $progress = new TermManagerProgressList();
  foreach ($progress as $progress_item) {
    $progress_item->displayStatus();
  }

  $location = _dennis_term_manager_get_files_folder();

  $form['csv_file'] = array(
    '#title' => t('Import'),
    '#type' => 'managed_file',
    '#description' => t('The CSV file to be processed.'),
    '#upload_validators' => array('file_validate_extensions' => array('csv tsv')),
    '#upload_location' => $location,
  );

  $form['buttons']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Import'),
    '#suffix' => '<span> ' . t('Click the "Import" button to process the file.') . '</span>',
  );
  $form['from'] = array(
    '#type' => 'item',
    '#prefix' => '<div><br /></div>',
    '#title' => t('Reports'),
    '#markup' => views_embed_view('csv_report'),
  );

  $form['#attached']['js'][] = array(
    'data' => '
      jQuery(document).ready(function () {

        var error_types = ["warning", "error"];

        jQuery(error_types).each(function( index, type ) {
            var selector = ".messages." + type;

            var count = jQuery(selector + " ul").children().length;

            if (count > 1) {
              var element = jQuery(selector);

              var button = jQuery("<button/>", {
                  text: "+",
                  click: function () {
                      if (jQuery(this).text() == "+") {
                          jQuery(this).text("-");
                          element.slideDown();
                      }
                      else {
                          jQuery(this).text("+");
                          element.slideUp();
                      }
                  }
              });

              var message = jQuery("<div/>", {
                  title: "Expand/Collapse",
                  text: "There were " + count + " " + type + " message(s). ",
                  class: type
              }).append(button);

              element.hide().before(message);
            }
        });
      });',
    'type' => 'inline',
  );

  return $form;
}

/**
 * Callback function for form submission.
 *
 * @param object $form
 *   Form Object
 * @param object $form_state
 *   Form State
 */
function dennis_term_manager_form_submit(&$form, &$form_state) {
  // Load the file.
  $file = file_load($form_state['values']['csv_file']);
  if (!$file) {
    drupal_set_message(t('Please upload the CSV/TSV file first.'), 'error');
  }
  else {
    // Save the file.
    _dennis_term_manager_file_save($file);

    // Process the file.
    $batch = _dennis_term_manager_batch_init($file);
    batch_set($batch);
  }
}

/**
 * Helper to copy the csv/tsv files and add an entry into the file usage table.
 *
 * @param $file_name
 *    The full path of the source file
 * @param $destination
 *    The uri of the destination
 * @param $replace
 *    The action to take when the file exists
 * @return $file
 *    The file object.
 */
function _dennis_term_manager_file_copy($file_name, $destination, $replace = FILE_EXISTS_REPLACE) {
  $file = new stdClass();
  $file->uri = file_unmanaged_copy($file_name, $destination, $replace);

  if ($file->uri === FALSE) {
    throw new Exception(t('!file_name cannot be saved', array(
      '!file_name' => $file_name,
    )));
  }

  $file->filename = basename($file->uri);

  if ($replace == FILE_EXISTS_REPLACE) {
    // Since we are replacing an existing file re-use its database record.
    $existing_files = file_load_multiple(array(), array('uri' => $file->uri));
    if (count($existing_files)) {
      $existing = reset($existing_files);
      $file->fid = $existing->fid;
    }
  }

  // Save the file.
  _dennis_term_manager_file_save($file);

  return $file;
}

/**
 * Helper to save the csv/tsv files and add an entry to the file usage table.
 *
 * @param $file
 *    The file object to be saved.
 * @return $file
 *    The file object.
 */
function _dennis_term_manager_file_save($file) {
  if (is_object($file)) {

    // Make file permanent.
    $file->status = FILE_STATUS_PERMANENT;
    file_save($file);

    // Add file usage.
    file_usage_add($file, 'dennis_term_manager', 'dennis_term_manager_csv_file', 1);
  }
  else {
    throw new Exception(t('!file_name cannot be saved', array(
      '!file_name' => $file->uri,
    )));
  }

  return $file;
}

/**
 * Implements hook_file_download().
 *
 * Handle private file permissions.
 */
function dennis_term_manager_file_download($uri, $field_type = 'file') {
  // Get the file record based on the URI. If not in the database just return.
  $files = file_load_multiple(array(), array('uri' => $uri));
  if (count($files)) {
    foreach ($files as $item) {
      // Since some database servers sometimes use a case-insensitive comparison
      // by default, double check that the filename is an exact match.
      if ($item->uri === $uri) {
        $file = $item;
        break;
      }
    }
  }
  if (!isset($file)) {
    return;
  }

  // If the file is used by dennis_term_manager, check that the current user has access.
  $usage = file_usage_list($file);
  if (isset($usage['dennis_term_manager']['dennis_term_manager_csv_file'])) {
    if (user_access('administer dennis term manager')) {
      // Grant access to user with term manager permissions.
      $headers = file_get_content_headers($file);
      return $headers;
    }
    // Access specifically denied.
    return -1;
  }

  // Not a term manager file so return null.
  return;
}

/**
 * Implements hook_batch_alter().
 */
function dennis_term_manager_batch_alter(&$batch) {
  // When the batch is created by Behat extension, disable progress to make it
  // execute immediately.
  if (isset($batch['sets']['0']['behat_extension']) &&
    $batch['sets']['0']['behat_extension'] === TRUE)
  {
    $batch['progressive'] = FALSE;
  }

}

/**
 * Prepare a batch definition that will process the file rows.
 */
function _dennis_term_manager_batch_init($file) {
  // Dry Run to validate and get operation list.
  $dryRun = new TermManagerDryRun();
  $dryRun->execute($file->uri);

  $operationList = $dryRun->getOperationList();

  // Prevent batch if there are no operation items.
  if (count($operationList) == 0) {
    drupal_set_message(t('There were no valid operations'));
    return;
  }

  if ($operationList->getErrorList()) {
    // Halt batch.
    return;
  }

  // Create file for reporting error.
  // - Use the same file name and change extenstion.
  $date = date('Y-m-d_H-i-s', REQUEST_TIME);

  $report_file_name = preg_replace("/[.](.*)/", "-" . $date . "-report.txt", $file->uri);
  if (!$report_file = _dennis_term_manager_open_report($report_file_name)) {
    return;
  }

  // Add file in progress.
  $progress_item = new TermManagerProgressItem($file->fid);
  $progress_item->setReportFid($report_file->fid);
  $progress_item->setOffsetQueueId();
  $progress_item->save();

  // Get a list of nodes that are not published but are scheduled to be published.
  $unpublished_sheduled_nodes = _dennis_term_manager_get_scheduled_nodes();
  // Get list of tids vs nodes. This is used to queue nodes that have any of the tids used by actions.
  $extra_nodes = _dennis_term_manager_list_node_tids($unpublished_sheduled_nodes);

  // Add each operation to the batch.
  $operations = array();
  foreach ($operationList as $i => $operationItem) {

    $options = array(
      'operation_item' => $operationItem,
      'report_fid' => $report_file->fid,
      'row' => $i,
      'extra_nodes' => $extra_nodes,
    );

    $operations[] = array(
      'dennis_term_manager_queue_operation',
      array($options),
    );
  }

  // Set final queue operation.
  $operations[] = array(
    'dennis_term_manager_queue_operation_complete',
    array(
      array(
        'fid' => $file->fid,
        'report_fid' => $report_file->fid,
      )
    ),
  );

  $batch = array(
    'operations' => $operations,
    //'finished' => 'batch_dennis_term_manager_finished',
    'title' => t('Processing operations'),
    'init_message' => t('Process is starting.'),
    'progress_message' => t('Processed @current out of @total steps.'),
    'error_message' => t('Batch has encountered an error.'),
  );

  return $batch;
}

/**
 * Process operations and pass each to cron queue.
 */
function dennis_term_manager_queue_operation($options, &$context) {
  $operationItem = $options['operation_item'];

  $baseData = array(
    'report_fid' => $options['report_fid'],
    'row' => $options['row'],
    'term_name' => $operationItem->term_name,
    'tid' => $operationItem->tid,
    'vid' => $operationItem->vid,
  );

  // Get the que to handle the.
  $q = DrupalQueue::get('dennis_term_manager_queue');

  switch ($operationItem->action) {
    case DENNIS_TERM_MANAGER_ACTION_MERGE:
      $nodeData = $baseData;
      $nodeData['action'] = DENNIS_TERM_MANAGER_ACTION_MERGE;
      $nodeData['target_tid'] = $operationItem->target_tid;
      $nodeData['target_vid'] = $operationItem->target_vid;
      $nodeData['target_field'] = $operationItem->target_field;

      // Get all nodes with source term reference.
      $nodes = _dennis_term_manager_get_associated_nodes($operationItem->tid);

      // Get list of extra nodes to queue if they use the tid in this context.
      $extra_nodes = $options['extra_nodes'];
      if (isset($extra_nodes[$operationItem->tid])) {
        $nodes = array_merge($nodes, $extra_nodes[$operationItem->tid]);
      }

      // Create queue for each node.
      foreach ($nodes as $node) {
        $nodeData['nid'] = $node->nid;
        // Queue item for Merge action.
        $q->createItem($nodeData);
      }

      // Merge term operation before it is deleted.
      $mergeData = $baseData;
      $mergeData['action'] = DENNIS_TERM_MANAGER_ACTION_MERGE;
      $mergeData['target_tid'] = $operationItem->target_tid;
      $mergeData['target_vid'] = $operationItem->target_vid;
      $mergeData['redirect'] = $operationItem->redirect;
      $q->createItem($mergeData);

      // Delete term once after nodes have been assigned to the target.
      $deleteData = $baseData;
      $deleteData['action'] = DENNIS_TERM_MANAGER_ACTION_DELETE;
      $q->createItem($deleteData);

      break;

    case DENNIS_TERM_MANAGER_ACTION_MOVE_PARENT:
      $data = $baseData;
      $data['action'] = $operationItem->action;
      $data['target_tid'] = $operationItem->target_tid;
      $data['target_term_name'] = $operationItem->target_term_name;
      $q->createItem($data);
      break;

    case DENNIS_TERM_MANAGER_ACTION_CREATE:
      $data = $baseData;
      $data['action'] = $operationItem->action;
      $data['parent_tid'] = $operationItem->parent_tid;
      $data['parent_term_name'] = $operationItem->parent_term_name;
      $q->createItem($data);
      break;

    case DENNIS_TERM_MANAGER_ACTION_DELETE:
      $nodeData = $baseData;
      $nodeData['action'] = $operationItem->action;
      $nodeData['target_tid'] = $operationItem->target_tid;
      // Get all nodes with source term reference.
      $nodes = _dennis_term_manager_get_associated_nodes($operationItem->tid);

      // Get list of extra nodes to queue if they use the tid in this context.
      $extra_nodes = $options['extra_nodes'];
      if (isset($extra_nodes[$operationItem->tid])) {
        $nodes = array_merge($nodes, $extra_nodes[$operationItem->tid]);
      }

      // Create queue for each node.
      foreach ($nodes as $node) {
        $nodeData['nid'] = $node->nid;
        // Queue item for Merge action.
        $q->createItem($nodeData);
      }

      $data = $baseData;
      $data['action'] = $operationItem->action;
      $q->createItem($data);
      break;

    case DENNIS_TERM_MANAGER_ACTION_RENAME:
      $data = $baseData;
      $data['action'] = $operationItem->action;
      $data['new_name'] = $operationItem->new_name;
      $q->createItem($data);
      break;
  }
}

/**
 * Add complete operation to queue.
 *
 * @param $data
 */
function dennis_term_manager_queue_operation_complete($data) {
  // Fid of uploaded file.
  $fid = $data['fid'];

  // Fid of report file.
  $report_fid = $data['report_fid'];

  // Register last queue item ID.
  $progress_item = new TermManagerProgressItem($fid);
  $progress_item->setFinalQueueId();
  $progress_item->save();

  // Create queue item to clean up this process.
  $queue_data = array(
    'action' => 'complete',
    'fid' => $fid,
    'report_fid' => $report_fid,
  );
  $q = DrupalQueue::get('dennis_term_manager_queue');
  $q->createItem($queue_data);
}

/**
 * Implements hook_cron_queue_info().
 */
function dennis_term_manager_cron_queue_info() {
  // Only process queue if term manager is enabled.
  if (!variable_get('dennis_term_manager_enabled', 1)) {
    return;
  }
  $queues['dennis_term_manager_queue'] = array(
    'worker callback' => 'dennis_term_manager_process_queue_item',
    'time' => (int) variable_get('dennis_term_manager_process_time', 60),
  );
  return $queues;
}

/**
 * Perform action on each queue item.
 *
 * @param array $data
 *   An array containing source and target taxonomy term data
 *
 */
function dennis_term_manager_process_queue_item($data) {
  // Process each row against their action column and validate their data.
  switch (strtolower($data['action'])) {
    case DENNIS_TERM_MANAGER_ACTION_CREATE:
      include_once 'dennis_term_manager_action_create.inc';
      _dennis_term_manager_process_action_create($data);
      break;

    case DENNIS_TERM_MANAGER_ACTION_DELETE:
      include_once 'dennis_term_manager_action_delete.inc';
      _dennis_term_manager_process_action_delete($data);
      break;

    case DENNIS_TERM_MANAGER_ACTION_RENAME:
      include_once 'dennis_term_manager_action_rename.inc';
      _dennis_term_manager_process_action_rename($data);
      break;

    case DENNIS_TERM_MANAGER_ACTION_MERGE:
      include_once 'dennis_term_manager_action_merge.inc';
      _dennis_term_manager_process_action_merge($data);
      break;

    case DENNIS_TERM_MANAGER_ACTION_MOVE_PARENT:
      include_once 'dennis_term_manager_action_move_parent.inc';
      _dennis_term_manager_process_action_move_parent($data);
      break;

    case DENNIS_TERM_MANAGER_ACTION_COMPLETE:
      _dennis_term_manager_process_action_complete($data);
      break;

    default:
      // Invalid Action.
      drupal_set_message(t("Invalid action in row @row", array(
        '@row' => $data['row'],
      )));
      break;
  }
}

/**
 * Helper to get vocabulary.
 *
 * @param : $vocabulary_name
 *   Vocabulary Name
 *
 * @return : $vocabulary
 *   array containing vocabulary
 */
function _dennis_term_manager_get_vocabulary($vocabulary_name) {
  // Return static if possible.
  $vocabulary = &drupal_static(__FUNCTION__ . $vocabulary_name, FALSE);
  if ($vocabulary !== FALSE) {
    return $vocabulary;
  }

  // Get vocabulary by vocabulary name.
  $query = db_select('taxonomy_vocabulary', 'tv');
  $query->fields('tv', array(
    'machine_name',
    'vid',
  ));
  $query->condition('tv.name', $vocabulary_name, '=');
  $vocabulary = $query->execute()->fetchObject();
  return $vocabulary;
}

/**
 * Helper to retrieve nodes associated with Term ID.
 *
 * We use the table taxonomy_index to avoid having to do join on every term reference field.
 * The problem with this is that nodes that are not published will not be included.
 * This causes a problem with nodes that are scheduled to be published, where the term ref fields
 * can be completely wipped out when the term actions are performed, i.e. term merge.
 * We have a workaround where we collect all these nodes using _dennis_term_manager_get_scheduled_nodes()
 * to create a list of nodes, with _dennis_term_manager_list_node_tids() that creates a list of these nodes
 * keyed by tid. Before we submit the items to the queue, we check this list to see if any of the
 * unpublished nodes will be affected by the action and queue them too.
 *
 * @param : $tid
 *   Taxonomy Term ID.
 *
 * @return array
 *   List of nodes.
 */
function _dennis_term_manager_get_associated_nodes($tid) {
  // Get nodes from taxonomy_index using target term tid.
  $query = db_select('taxonomy_index', 'ti');
  $query->fields('ti', array(
    'nid',
  ));
  $query->condition('ti.tid', $tid, '=');
  $nodes = $query->execute()->fetchAll();

  return $nodes;
}

/**
 * Helper to retrieve nodes that are not published and scheduled to be published.
 *
 * Since we use the taxonomy_index table on _dennis_term_manager_get_associated_nodes(),
 * it will only return nodes that are published. This is a workaround to get the unpublished
 * nodes that are scheduled to be published.
 *
 * @return array
 *   List of nodes.
 */
function _dennis_term_manager_get_scheduled_nodes() {
  $nodes = [];
  $supported_modules = ['rules_scheduler', 'scheduler'];

  foreach ($supported_modules as $name) {
    // Check if the module is enabled.
    if (module_exists($name)) {
      $query = db_select('node', 'n');
      $query->fields('n', array(
        'nid',
      ));
      $query->condition('n.status', 0, '=');

      switch ($name) {
        case 'rules_scheduler':
          // Check if field exists, as rule_scheduler could be enabled but not setup.
          $map = field_info_field_map();
          if (!empty($map['field_schedule_publish']['bundles']['node'])) {
            // Inner join node that are scheduled to be published.
            $query->innerJoin('field_data_field_schedule_publish', 's', 's.entity_id = n.nid');
            $query->condition('s.field_schedule_publish_value', 1, '=');
            $nodes = array_merge($nodes, $query->execute()->fetchCol('nid'));
          }
          break;

        case 'scheduler':
          // Inner join node that are scheduled to be published.
          $query->innerJoin('scheduler', 's', 's.nid = n.nid AND s.publish_on > 0');
          $nodes = array_merge($nodes, $query->execute()->fetchCol('nid'));
          break;
      }
    }
  }
  $nodes = array_unique($nodes);

  return $nodes;
}

/**
 * Helper to get term ID.
 *
 * @param : $term_name
 *   Taxonomy Term Name
 * @param : $vid
 *   Vocabulary Machine Name
 *
 * @return int
 *   Taxonomy Term ID or false in case not found
 */
function _dennis_term_manager_get_tid($term_name, $vid) {
  if ($vocabulary = taxonomy_vocabulary_load($vid)) {
    $term_name = _dennis_term_manager_decode_specific_chars($term_name);
    if ($term = taxonomy_get_term_by_name($term_name, $vocabulary->machine_name)) {
      $first_term = array_values($term);
      return $first_term[0]->tid;
    }
  }
}

/**
 * Helper to check if source term is the parent of target term.
 *
 * @param int $target_term_id
 *   Taxonomy Term id
 * @param int $term_id
 *   Taxonomy Term Id
 */
function _dennis_term_manager_term_is_parent($target_term_id, $term_id) {
  $ancestors = taxonomy_get_parents_all($target_term_id);
  // If there are no parents, it's already level 1 term.
  if (empty($ancestors)) {
    return TRUE;
  }
  // Overwise check the term for not beeing checked term itself.
  else {
    foreach ($ancestors as $value) {
      if ($term_id == $value->tid) {
        return FALSE;
      }
    }
  }

  return TRUE;
}

/**
 * Helper to write errors in report file.
 *
 * @param: $file_name
 *   URI of file
 * @param: $error_message
 *   Error Message.
 */
function _dennis_term_manager_write_report($fid, $error_message) {
  $file = file_load($fid);
  if (isset($file->uri) && ($report_handle = fopen($file->uri, "a")) != FALSE) {
    fwrite($report_handle, $error_message . PHP_EOL);
    fclose($report_handle);

    // Clear stat cache to get correct filesize.
    clearstatcache(FALSE, $file->uri);

    file_save($file);
  }
  else {
    // Report on watchdog.
    watchdog('DENNIS_TERM_MANAGER', t('Not able to write in report file. error %message'), array(
      '%message' => $error_message,
    ));
  }
}

/**
 * Opens a new report and return fid.
 *
 * @param $file_path
 */
function _dennis_term_manager_open_report($file_path) {
  // Create new managed file.
  if ($file = file_save_data('', $file_path, FILE_EXISTS_RENAME)) {
    // Add file usage.
    file_usage_add($file, 'dennis_term_manager', 'dennis_term_manager_csv_file', 1);
    return $file;
  }
  else {
    drupal_set_message(t('Could not open %file', array('%file' => $file_path)));
    return FALSE;
  }
}

/**
 * Helper function, to decode encoded string.
 *
 * We don't want to decode all the string, so let's take in consideration
 * encoded chars.
 */
function _dennis_term_manager_decode_specific_chars($string) {
  return str_replace('&amp;', '&', $string);
}

/**
 * Get allowed vocabularies for specified field.
 *
 * @param $field_name
 */
function _dennis_term_manager_get_field_allowed_vocabularies($field_name) {
  // Return cached allowed vocabularies if available.
  $allowed_vocabularies = &drupal_static(__FUNCTION__ . $field_name, FALSE);
  if ($allowed_vocabularies !== FALSE) {
    return $allowed_vocabularies;
  }

  // Build arry of allowed vocabularies.
  $allowed_vocabularies = array();
  if ($field_info = field_info_field($field_name)) {
    if (isset($field_info['settings']['allowed_values']) && is_array($field_info['settings']['allowed_values'])) {
      foreach ($field_info['settings']['allowed_values'] as $allowed_value) {
        if (isset($allowed_value['vocabulary'])) {
          if ($vocabulary = taxonomy_vocabulary_machine_name_load($allowed_value['vocabulary'])) {
            $allowed_vocabularies[$vocabulary->vid] = $allowed_value['vocabulary'];
          }
        }
      }
    }
  }

  return $allowed_vocabularies;
}

/**
 * Get allowed fields for specified vocabulary.
 *
 * @param $vid
 */
function _dennis_term_manager_get_vocabulary_allowed_fields($vid) {
  // Return cached allowed fields if available.
  $allowed_fields = &drupal_static(__FUNCTION__ . $vid, FALSE);
  if ($allowed_fields !== FALSE) {
    return $allowed_fields;
  }

  // Build array of allowed fields for this vocabulary.
  $allowed_fields = array();
  $taxonomy_fields = field_read_fields(array('type' => 'taxonomy_term_reference'));
  foreach ($taxonomy_fields as $field_info) {
    $allowed_vocabularies = _dennis_term_manager_get_field_allowed_vocabularies($field_info['field_name']);
    if (isset($allowed_vocabularies[$vid])) {
      $allowed_fields[] = $field_info['field_name'];
    }
  }

  return $allowed_fields;
}

/**
 * Clean up current process.
 *
 * @param $data
 */
function _dennis_term_manager_process_action_complete($data) {
  // Remove from in progress.
  try {
    $progress_item = new TermManagerProgressItem($data['fid']);
    $progress_item->delete();
    // Update report.
    _dennis_term_manager_write_report($data['report_fid'], t('Completed'));
  } catch (Exception $e) {
    // Send to error report.
    _dennis_term_manager_write_report($data['report_fid'], $e->getMessage());
  }
}

/**
 * Helper to get list of term reference fields.
 *
 * @param $node_type
 *    The node type.
 * @return
 *    List of term reference field names.
 */
function _dennis_term_manager_get_taxonomy_fields($node_type) {
  $taxonomy_fields = &drupal_static(__FUNCTION__ . $node_type, array());
  if (!empty($taxonomy_fields[$node_type])) {
    return $taxonomy_fields[$node_type];
  }

  if ($entity_info = field_info_instances('node', $node_type)) {
    foreach ($entity_info as $field) {
      $field_name = $field['field_name'];
      $field_info = field_info_field($field_name);
      if ($field_info['type'] == 'taxonomy_term_reference') {
        $taxonomy_fields[$node_type][$field_name] = $field_info;
      }
    }
  }

  return $taxonomy_fields[$node_type];
}

/**
 * Helper clean left over tids on term reference fields after a delete or merge action.
 *
 * @param $node
 *    The node to be cleaned up.
 * @param $data
 *    Stores the information related to the current action being executed.
 * @return
 *    A flag to inform when the node has been changed.
 */
function _dennis_term_manager_clean_tids($node, &$data) {

  $taxonomy_fields = _dennis_term_manager_get_taxonomy_fields($node->type);

  // Remove source tid from fields.
  foreach ($taxonomy_fields as $field_name => $field_info) {
    // Check each node field for term reference.
    if (isset($node->{$field_name}[LANGUAGE_NONE][0])) {
      foreach ($node->{$field_name}[LANGUAGE_NONE] as $key => $value) {
        if ($value['tid'] == $data['tid']) {
          unset($node->{$field_name}[LANGUAGE_NONE][$key]);
          $data['node_changed'] = TRUE;
        }
      }
    }
  }

  return $data['node_changed'];
}

/**
 * Helper to find tids used on nodes that are not published but scheduled to be published.
 *
 * @param $node
 *    The node to be cleaned up.
 * @param $list
 *    The list of tids used by the recursive call.
 * @retun $nodes
 *    A list of nodes keyed by tid.
 */
function _dennis_term_manager_list_node_tids($nodes, $list = array()) {

  if ($nid = array_shift($nodes)) {
    $node = node_load($nid);

    $taxonomy_fields = _dennis_term_manager_get_taxonomy_fields($node->type);

    // Remove source tid from fields.
    foreach ($taxonomy_fields as $field_name => $field_info) {
      // Check each node field for term reference.
      if (isset($node->{$field_name}[LANGUAGE_NONE][0])) {
        foreach ($node->{$field_name}[LANGUAGE_NONE] as $key => $value) {
          if (!empty($value['tid'])) {
            $tid = $value['tid'];

            // No need to return the full node, just nid will be enough.
            $new_node = new stdClass();
            $new_node->nid = $node->nid;

            $list[$tid][] = $new_node;// $node
          }
        }
      }
    }
    return _dennis_term_manager_list_node_tids($nodes, $list);
  }

  return $list;
}

/**
 * CSV/TSV files should always have these columns.
 */
function dennis_term_manager_default_columns() {
  return array(
    'vocabulary_name',
    'term_name',
    'tid',
    'path',
    'node_count',
    'term_child_count',
    'parent_term_name',
    'action',
    'target_term_name',
    'target_tid',
    'target_vocabulary_name',
    'target_field',
    'new_name',
    'redirect',
  );
}

/**
 * Implements hook_fe_paths_file_process_available_alter().
 */
function dennis_term_manager_fe_paths_file_process_available_alter(&$allow_move, $file) {
  // Prevent fe_paths from moving the uploaded CSV files.
  if (strpos($file->uri, '/term_manager/') !== FALSE) {
    $allow_move = FALSE;
  }
}

/**
 * Helper to retrieve the files folder.
 */
function _dennis_term_manager_get_files_folder() {
  // Store CSV/TSV files and reports in private file location if available.
  if (variable_get('file_private_path', '')) {
    $location = DENNIS_TERM_MANAGER_PRIVATE_FOLDER;
  }
  else {
    $location = DENNIS_TERM_MANAGER_PUBLIC_FOLDER;
    // Warn user that files will be publicly accessible.
    $config_link = l(
      'Please configure the private file system path to store report privately',
      'admin/config/media/file-system'
    );
    $warning_message = t('Files will be stored in the public file directory. !config_link', array('!config_link' => $config_link));
    drupal_set_message($warning_message, 'warning');
  }

  // Test if folder exists and try to create it if necessary.
  if (!is_dir($location) && !drupal_mkdir($location, NULL, TRUE)) {
    watchdog('file system', 'The directory %directory does not exist and could not be created.', array('%directory' => $location), WATCHDOG_ERROR);
  }
  if (is_dir($location) && !is_writable($location) && !drupal_chmod($location)) {
    // If the directory is not writable and cannot be made so.
    watchdog('file system', 'The directory %directory exists but is not writable and could not be made writable.', array('%directory' => $location), WATCHDOG_ERROR);
  }
  elseif (is_dir($location)) {
    // Create private .htaccess file.
    file_create_htaccess($location);
    return $location;
  }

  throw new Exception(t('Error trying to copy files to !name folder. Make sure the folder exists and you have writting permission.', array(
    '!name' => $location,
  )));
}

/**
 * Helper to generate machine names.
 *
 * @param $name
 * @return string
 */
function _dennis_term_manager_machine_name($name) {
  return strtolower(preg_replace('@[^a-zA-Z0-9_]+@', '_', $name));
}

/**
 * Helper to count delimiters and see what is the mostly used.
 */
function _dennis_term_manager_detect_delimiter($str, $delimiter = NULL) {
  // Get number of rows.
  preg_match_all("/\n/", $str, $matches);
  $rows = count($matches[0]);

  $cur_cnt = 0;
  foreach (_dennis_term_manager_get_delimiters() as $key => $value) {
    preg_match_all("/\\$value/", $str, $matches);
    $count = count($matches[0]);

    //echo "$key($value) = " . count($matches[0]) . PHP_EOL;

    if ($count > $cur_cnt) {
      $cur_cnt = $count;

      // Only use this delimiter if it happens at least once per row.
      if ($count > $rows) {
        $delimiter = $value;
      }
    }
  }

  return $delimiter;
}

/**
 * Helper to return list of delimiters.
 */
function _dennis_term_manager_get_delimiters() {
  $delimiters = array(
    'comma' => ",",
    'semicolon' => ";",
    'tab' => "\t",
    'pipe' => "|",
    'colon' => ":",
    'space' => " ",
  );

  return $delimiters;
}

/**
 * Helper to sort the array descending by key;
 */
function _dennis_term_manager_sbk($a, $b) {
  global $dennis_term_manager_sbk;
  $key = $dennis_term_manager_sbk;

  if ($a[$key] == $b[$key]) {
    return 0;
  }
  return ($a[$key] < $b[$key]) ? -1 : 1;
}
